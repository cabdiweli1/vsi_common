#!/usr/bin/env false

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

#*# linux/string_tools

#**
# ============
# String Tools
# ============
#
# .. default-domain:: bash
#
# .. file:: string_tools.bsh
#
#**


# https://stackoverflow.com/a/3352015/4166604

#**
# .. function:: ltrim
#
# :Arguments: * ``$1`` - String to trim
#             * [``$2``] - Characters to trim. Default: [``:space:``]
# :Output: *stdout* - The trimmed string
#
# Left trim a string
#
# .. seealso::
#   :func:`trim` Trim from both ends in one call
#**
function ltrim()
{
  echo "${1#"${1%%[!${2-[:space:]}]*}"}"
}

#**
# .. function:: rtrim
#
# :Arguments: * ``$1`` - String to trim
#             * [``$2``] - Characters to trim. Default: [``:space:``]
# :Output: *stdout* - The trimmed string
#
# Right trim a string
#
# .. seealso::
#   :func:`trim` Trim from both ends in one call
#**
function rtrim()
{
  echo "${1%"${1##*[!${2-[:space:]}]}"}"
}

#**
# .. function:: trim
#
# :Arguments: * ``$1`` - String to trim
#             * [``$2``] - Characters to trim. Default: [``:space:``]. Can be another character or character classes, such as: alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit. For multiple characters/classes, use standard pattern matching syntax, minus the []
# :Output: *stdout* - The trimmed string
#
# Trim a string
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   trim ' abcAcba ' # Trim the spaces
#   Result: 'abcAbca'
#
#   trim 'abcAcba' a # Trims the letter a off
#   Result: 'bcAcb'
#
#   trim 'abcAcba' [:lower:] # Trims lowercase letters
#   Result: 'A'
#
#   trim 'abcdAdcba' a-c # Trims range a-c
#   Result: 'dAd'
#
#   trim 'aebcAcbea' aeiou # Trims vowels
#   Result: 'bcAcb'
#
#   See Bash man on "Pattern Matching" for more possibilities. $2 is essentially
#   placed inside a set of []
#
# .. seealso::
#   :func:`ltrim` Trim only from the left
#   :func:`rtrim` Trim only from the right
#**
function trim()
{
  local x
  x="${1#"${1%%[!${2-[:space:]}]*}"}"
  echo "${x%"${x##*[!${2-[:space:]}]}"}"
}


#**
# .. function:: quote_escape
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The string with ' escaped properly
#
# Properly escape string for bash, adds ' for you, does not need extra quotes added to string. Useful for printing out instructions that are meant to be copy and pasted, no matter what characters are in the string. Also useful for ``eval``
#
# ``printf '%q' "$foo"`` does not always work exactly as intended with ``eval`` on bash 3.2. Either the ``\`` is not expanded when double quotes are uses, or ``~`` is expanded without double quotes. With this function, no bash expansion ever occurs.
#
# Quotes do not need to be added to any expression, as ``'`` are added for you.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   eval "x=$(quote_escape "Hi \"  'ya \"")" # <-- Never add quotes after the =
#   [ "${x}" = "Hi \"  'ya \"" ]
#
# .. seealso::
#   :func:`quote_substitute_escape` for use in ``${x-something}``
#**
function quote_escape()
{
  # Gets around Bash <= 4.2 issue
  # https://unix.stackexchange.com/a/411047/123413
  local foo42=\'\\\'\'
  echo "'${1//\'/${foo42}}'"
  # All other bash substitutions do not occur in '
}

#**
# .. function:: quote_unescape
#
# :Arguments: * ``$1`` - Sring to unescape
# :Output: *stdout* - Unescaped string
#
# Unquote a string quoted using bashes rules for quotes, without using eval.
#
# The ``trap -p`` command outputs string using the single quote notation and only escapes ``'``, while ``declare -p`` used the double quote notation and only has to escape ``\`$"``. Only these escape charaters are supported, all other escapes will be left in.
#
# .. warning::
#
#     This only works for specific single quoted strings, like that outputted from :func:`quote_escape`. Mixing a string with ``"`` or ``$'`` will result in error. The only concatination of two strings supported is ``'\''``.
#**
function quote_unescape()
{
  local x
  if [ "${#1}" -ge 2 ]; then
    if [ "${1:0:1}" = "'"  -a "${1: -1}" = "'" ]; then
      x="${1:1:${#1}-2}" # Remove surrounding quotes
      # Gets around Bash <= 4.2 issue
      # https://unix.stackexchange.com/a/411047/123413
      local foo42="'"
      echo "${x//\'\\\'\'/${foo42}}"
      return
    elif [ "${1:0:1}" = '"'  -a "${1: -1}" = '"' ]; then
      x="${1:1:${#1}-2}" # Remove surrounding quotes
      x="${x//\\\$/\$}"
      x="${x//\\\`/\`}"
      x="${x//\\\"/\"}"
      echo "${x//\\\\/\\}"
      # printf '%b\n' "${x}" # supports //, but I think it's wrong to do \t \n, etc...
      return
    fi
  fi
  echo "${1}"
}

#**
# .. function:: quote_substitute_escape
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The string escaped properly
#
# Similar to :func:`quote_escape`, but can be used in the same use cases as :func:`quote_escape` and for variable substitution, e.g. the ``bar`` in ``${foo-bar}``.
#
# Unlike :func:`quote_escape`, quotes do need to be added to any expression. This is because quotes can be added outside the evaluation point of :func:`quote_substitute_escape`.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   unset y
#   eval "x=\"${y-$(quote_substitute_escape "Hi \"  'ya \"")}\"" # <-- Need the \"
#   # Always add the \" after the =
#   [ "${x}" = 'Hi "  '\''ya "' ]
#
#   #also
#
#   eval "x=\"$(quote_substitute_escape "Hi \"  'ya \"")\"" # <-- Need the \"
#   [ "${x}" = 'Hi "  '\''ya "' ]
#
# .. seealso::
#   :func:`quote_escape` for the more generic case not in ``${}``
#**
function quote_substitute_escape()
{
  local x="${1//\\/\\\\}" # First excape \ to \\
  x="${x//\"/\\\"}"       # Then escape "
  x="${x//\$/\\\$}"       # Now start disabling Bash substitutions. $
  echo "${x//\`/\\\`}"    # And the last bash substitution, `
  # All other bash substitutions do not occur in "
}

#**
# .. function:: regex_escape
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The escaped string
#
# Adds '\' to the string, so it can be used as a literal string in a regex expression, assuming / is the search command separator
#
# .. var:: regex_escape_threshold
#
# The length threshold between using the pure bash version and sed version to. Set to 600 on Windows, else 50
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   $ regex_escape '***TEST***'
#   \*\*\*TEST\*\*\*
#
# .. Note::
#   An extra newline always shows up at the end, just like `echo` (without `-n`) would.
#   Only works for Basic Regex Expressions (BRE). A different function/flag would be needed for extended, as the rules are incompatible with each other (for example ``()``)
#**
if [ "${OS-}" = "Windows_NT" ]; then
  regex_escape_threshold=600
else
  regex_escape_threshold=50
fi

# https://unix.stackexchange.com/a/33005/123413
# Normal regex escapes $.*[\^,   (){}+?| must NOT be escaped
# Extended must escape (), and who know whatelse

function regex_escape()
{
  local out=''
  local -i i=0
  local str="${1}"
  if [ "${#str}" -gt "${regex_escape_threshold}" ]; then
    # Faster after sed is started
    sed '# Read all lines into one buffer
         :combine
         $bdone
         N
         bcombine
         :done
         s/[[$.*\^/]/\\&/g' <<< "${str}"
  else
    # Slower, but no process to load, so faster for short strings. On windows
    # this can be a big deal
    # local regex='[[$.*\^/]'
    while (( i < ${#str} )); do
      if [[ ${str:$i:1} =~ [[$.*\\/^] ]]; then
        out+="\\${str:$i:1}"
      else
        out+="${str:$i:1}"
      fi
      i+=1
    done
    echo "$out"
  fi
}

#**
# .. function:: regex_escape_range
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The escaped string range, including []
#
# Adds '\' to the string, so it can be used as a literal string in a regex expression as a character range. Basically this handles the special cases for ``^``, ``-``, and ``]``
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   $ regex_escape_range '^hk]'
#   []hk^]
#**
function regex_escape_range()
{
  local str="${1}"

  # Special case of ^ by itself, [^] will not work
  if [ "${str}" = "^" ]; then
    echo -n "^"
    return 0
  fi

  # ^ must not be fisrt
  if [[ ${str} =~ \^ ]]; then
    str="${str//^/}^"
  fi
  # - must be last
  if [[ ${str} =~ - ]]; then
    str="${str//-/}-"
  fi
  # ] must be first
  if [[ ${str} =~ ] ]]; then
    str="]${str//]/}"
  fi
  echo -n "[${str}]"
}

#**
# .. function:: uppercase
#
# :Arguments: * ``$1`` - String to convert
# :Output: *stdout* - String in uppercase
#
# Converts a string to uppercase, using ``bash`` or ``tr``
#**
if [ ${BASH_VERSINFO[0]} -ge 4 ]; then
  function uppercase()
  {
    echo "${1^^}"
  }
else
  function uppercase()
  {
    tr '[a-z]' '[A-Z]' <<< "${1}"
  }
fi

#**
# .. function:: lowercase
#
# :Arguments: * ``$1`` - String to convert
# :Output: *stdout* - String in lowercase
#
# Converts a string to lowercase, using ``bash`` or ``tr``
#**
if [ ${BASH_VERSINFO[0]} -ge 4 ]; then
  function lowercase()
  {
    echo "${1,,}"
  }
else
  function lowercase()
  {
    tr '[A-Z]' '[a-z]' <<< "${1}"
  }
fi
