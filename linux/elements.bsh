#!/usr/bin/env false
# Source this file

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

#*# linux/elements

#**
# ==================
# Array Manipulation
# ==================
#
# .. default-domain:: bash
#
# .. file:: elements.bsh
#
# Set of -euE safe functions to make ``bash`` array manipulation easy
#
# Set of functions for deleting, prepending and appending without repetition. Versions using actual ``Bash`` arrays are suffixed with an _a, else it works on delimiter (IFS) separated string
#
# These functions use variable indirection when possible to make using them friendlier.
#
# .. note::
#   Not intended for POSIX sh, works on bash and others like ksh
#**

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/set_flags.bsh"
source "${VSI_COMMON_DIR}/linux/isin"

#**
# .. function:: dynamic_set_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * [``$2...``] - Values to set
#
# Dynamically set an array to values from arguments
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   dynamic_set_a my_array_name 11 "2 2" 33
#   # Is like executing
#   # my_array_name=(11 "2 2" 33)
#**
if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "440" ]; then
  function dynamic_set_a()
  {
    # This way the user may use the names x
    if [ "${1}" != "x" ]; then
      local -n x="${1}"
    fi
    shift 1
    x=(${@+"${@}"})
  }
else
  function dynamic_set_a()
  {
    if [ "${1}" = "__i" ]; then
      # In case the user uses the name __i
      shift 1
      __i=(${@+"${@}"})
    else
      clear_a "${1}"
      local IFS='' # If I don't do this, leading and trailing whitespace are dropped
      local __i
      for (( __i=2; __i<=$#; __i++ )); do
        # Can't use here-string because that adds an extra newline. Also, since
        # there is no extra newline, read returns false
        read -r -d '' "${1}[$(($__i-2))]" < <(printf '%s' "${!__i}") || :
      done
    fi
  }
fi

#**
# .. function:: dynamic_set
#
# :Arguments: * ``$1`` - Name of variable to be set
#             * ``$2`` - Value to set
#
# Dynamically set a variable to a value. There are a number of properties that need to be preserved when setting a variable, export, local, global, etc... This method will allow you to indirectly set a variable while preserving these properties.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#    dynamic_set my_name '11 "2 2" 33'
#    # Is like executing
#    # my_array_name='11 "2 2" 33'
#**

# The following has the following but, which is why only ``read`` is used.
#
# .. bugs::
#
#    .. code:: bash
#
#       $ export foo # no value set, not even null
#       $ dynamic_set
#
# if [[ ${BASH_VERSINFO[0]}${BASH_VERSINFO[1]} -ge 44 ]]; then
#   function dynamic_set()
#   {
#     # Check if is exported, this only works in bash 4.4 or newer, but is very fast
#     if [[ ${!1@a} = *x* ]]; then # 0.055
#       # Set and export, very fast
#       export "${1}=${2-}" # 0.048
#     else
#       # Set and don't export. Trying declare will set as a local variable if not
#       # already set, so we don't do that
#       export -n "${1}=${2-}" # 0.048
#     fi
#   }
# else
function dynamic_set()
{
  # backwards compat fairly slow method, but faster than using declare -p (20.0!)
  # compgen (0.779) and will auto handle export vs no export, so just use read
  IFS='' read -r -d '' "${1}" < <(printf '%s' "${2-}") || : #0.739
}
# fi

#**
# .. function:: clear_a
#
# :Arguments: ``$1`` - Name of array to be cleared
# :Output: Returns ``1`` on invalid variable name
#
# Slightly safer indirect clear array
#
# .. note::
#   Still uses eval on older versions of bash, but makes sure the variable name appears valid
#**
if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "44" ]; then
  function clear_a()
  {
    if [ "${1}" != "x" ]; then
      local -n x="${1}"
    fi
    x=()
  }
else
  function clear_a()
  {
    # https://stackoverflow.com/a/2821201/4166604
    if [[ ! ${1} =~ [a-zA-Z_]+[a-zA-Z0-9_]* ]]; then
      # Create the same error message as the bash 4.4 version
      echo "bash: local: \`${1}': invalid variable name for name reference" >&2
      return 1
    fi

    # Do NOT use unset here. If you do that, you will lose "local" status if the
    # variable that $1 points to has it. This can have MANY unintended
    # consequences which is generally BAD! Gotta eval :(
    # https://stackoverflow.com/questions/10497425/is-it-possible-to-use-array-in-bash#comment74842477_10497539
    eval "${1}=()"
  }
fi

#**
# .. function:: remove_element_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2`` - Value to be removed
#
# Removes all instances of a value from an array
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=(11 22 33 22 44)
#   remove_element_a x 22
#   # declare -a x='([0]="11" [1]="33" [2]="44")'
#
# .. note::
#   The resulting array is sequentially indexed, which is not typical in ``bash`` when removing elements from an array
#**
function remove_element_a()
{
  # Handle local name collisions
  if [ "${1}" = "__x" ]; then
    local y=(${__x[@]+"${__x[@]}"})
    remove_element_a y "${2}"
    __x=(${y[@]+"${y[@]}"})
  elif [ "${1}" = "__i" ]; then
    local y=(${__i[@]+"${__i[@]}"})
    remove_element_a y "${2}"
    __i=(${y[@]+"${y[@]}"})
  else
    # We have to check ${1}[@] here, because there is a change the first
    # element of the array is not set, but the rest of the array is.
    local __x="${1}[@]"
    # Do not use -n here, because "${blah[@]+set}" expands to ZERO arguments,
    # not one empty one, thus making the final test "test -n -n" which is true
    # So = "set" is the right way to do this when [@] is involved
    if [ "${!__x+is_set}" = "is_set" ]; then
      __x=( ${!__x} )
    else # If it's empty/does not exist, there is nothing to remove
      return 0
    fi
    local __i

    for __i in "${!__x[@]}"; do
      if [ "${__x[$__i]}" == "${2}" ]; then
        # http://wiki.bash-hackers.org/syntax/arrays#destruction
        unset "__x[$__i]"
      fi
    done

    clear_a "${1}"

    dynamic_set_a "${1}" ${__x[@]+"${__x[@]}"}
  fi
}

# _remove_element_a "${1}" "${1}[@]" "${2}"

#**
# .. function:: remove_element
#
# :Arguments: * ``$1`` - Name of string to be set
#             * ``$2`` - String to be removed
# :Paramters: [``IFS``] - IFS Separator used
#
# String version of remove_element_a
#**
function remove_element()
{
  if [ "${1}" = "__x" ]; then
    # In case the user uses the name __y
    local y="${__x-}"
    remove_element y "${2}"
    __x=${y+"${y[*]}"}
  else
    local __x=()
    if [ -n "${!1+set}" ]; then
      # Convert to array
      __x=( ${!1} )
    fi
    # Use already existing funtion
    remove_element_a __x "${2}"

    dynamic_set "${1}" ${__x+"${__x[*]}"}
  fi
}

#**
# .. function:: add_element
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2``... - Values to be appended
#
# Just appends to array, allows repeats. ``${1}+=("${2}")``
#**
function add_element_a()
{
  :
}

#**
# .. function:: add_element_post_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2`` - Value to be appended
#
# Add a value to the end of an array
#
# Removes all copies of the value from the array first, and then appends to the end of the array
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=(22 11 22 33)
#   add_element_post_a x 22
#   declare -p x
#   # declare -a x='([0]="11" [1]="33" [2]="22")'
#
# .. note::
#   The resulting array is sequentially indexed
#**
function add_element_post_a()
{
  remove_element_a "${1}" "${2}"
  if [ "${1}" = "__x" ]; then
    local y=(${__x[@]+"${__x[@]}"})
    add_element_post_a y "${2}"
    __x=(${y[@]+"${y[@]}"})
  else
    local __x="${1}[@]"
    dynamic_set_a "${1}" ${!__x+"${!__x}"} "${2}"
  fi
}

#**
# .. function:: add_element_post
#
# :Arguments: * ``$1`` - Name of string to be set
#             * ``$2`` - String to be appended
# :Parameters: [``IFS``] - IFS Separator used
#
# String version of :func:`add_element_post_a`
#**
function add_element_post()
{
  if [ "${1}" = "__x" ]; then
    local y=( ${__x-} )
    add_element_post_a y "${2}"
    __x=${y+"${y[*]}"}
  else
    local __x=()
    if [ -n "${!1+set}" ]; then
      __x=( ${!1} )
    fi
    add_element_post_a __x "${2}"

    dynamic_set "${1}" ${__x+"${__x[*]}"}
  fi
}

#**
# .. function:: add_element_pre_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2`` - Value to be prepended
#
# Add a value to the beginning of an array
#
# Removes all copies of the value from the array first, and then prepends to the beginning of the array
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=(11 22 33 22)
#   add_element_pre_a x 22
#   declare -p x
#   # declare -a x='([0]="22" [1]="11" [2]="33")'
#
# .. note::
#   The resulting array is sequentially indexed
#**
function add_element_pre_a()
{
  remove_element_a "${1}" "${2}"
  if [ "${1}" = "__x" ]; then
    local y=(${__x[@]+"${__x[@]}"})
    add_element_pre_a y "${2}"
    __x=(${y[@]+"${y[@]}"})
  else
    local __x=()
    # remove_element_a makes $1 contiguous, so no need to check $!1[@]
    if [ -n "${!1+set}" ]; then
      __x="${1}[@]"
      __x=( ${!__x} )
    fi
    dynamic_set_a "${1}" "${2}" ${__x+"${__x[@]}"}
  fi
}

#**
# .. function:: add_element_pre
#
# :Arguments: * ``$1`` - Name of string to be set
#             * ``$2`` - String to be appended
# :Parameters: [``IFS``] - IFS Separator used
#
# String version of :func:`add_element_post_a`
#**
function add_element_pre ()
{
  if [ "${1}" = "__x" ]; then
    local y=( ${__x-} )
    add_element_pre_a y "${2}"
    __x=${y+"${y[*]}"}
  else
    local __x=()
    if [ -n "${!1+set}" ]; then
      __x=( ${!1} )
    fi
    add_element_pre_a __x "${2}"

    dynamic_set "${1}" ${__x+"${__x[*]}"}
  fi
}

#**
# .. function:: cmp_elements_a
#
# :Arguments: * ``$1`` - First array name
#             * ``$2`` - Second array name
# :Output: Return Value: ``0`` - Identical, ``1`` - Not identical
#
# Checks if two arrays are the same
#**
function cmp_elements_a()
{
  # # Handle the trivial case. This isn't neccessary since as it happens using
  # # "__x __x" or "__y __y" yields the correct answer, this just bypasses that
  # if [ "${1}" = "${2}" ]; then
  #   return 0
  # fi
  # Handling this corner case would just slow things down in the normal case

  # Swap the order, so that only 1 could be __x, and only 2 could be __y. This will
  # simplify the logic below.
  if [ "${1}" = "__y" ] || [ "${2}" = "__x" ]; then
    _cmp_elements_a "${2}[@]" "${1}[@]"
  else
    _cmp_elements_a "${1}[@]" "${2}[@]"
  fi

  # It happens that the below will work if both arguments are __x or __y, although
  # "__x" works through a "buggy" route (__y ends up being a copy of the copy of __x,
  # rather than just a copy of __x), but the answer is correct, so it's all good
}

function _cmp_elements_a()
{
  # Have to copy https://unix.stackexchange.com/a/374094/123413 Thanks darwin!
  local __x=(${!1+"${!1}"})
  local __y=(${!2+"${!2}"})
  if [ ${#__x[@]} -ne ${#__y[@]} ]; then
    return 1
  fi

  local z
  for ((z=0; z<${#__x[@]}; z++)); do
    if [ "${__x[$z]}" != "${__y[$z]}" ]; then
      return 1
    fi
  done

  return 0
}

#**
# .. function:: cmp_elements
#
# :Arguments: * ``$1`` - First string name
#             * ``$2`` - Second string name
# :Output: Return Value: ``0`` - Identical, ``1`` - Not identical
#
# String version of :func:`cmp_elements_a`
#**
function cmp_elements()
{
  # Handle the trivial case. This is neccessary unlike the array version,
  # because x/y are strings, not arrays, and the logic breaks down
  if [ "${1}" = "${2}" ]; then
    return 0
  fi

  # Swap the order, so that only 1 could be x, and only 2 could be y. This will
  # simplify the logic below.
  if [ "${1}" = "__y" ] || [ "${2}" = "__x" ]; then
    set -- "${2}" "${1}"
  fi

  local __x=( ${!1} )
  local __y=( ${!2} )

  cmp_elements_a __x __y
  return $?
}

#**
# .. function:: split_s
#
# :Arguments: * ``$1`` - Target array name
#             * ``$2``... - Strings
# :Parameters: * [``MIFS``] - A Multichararater Internal Field Separator.
#              * Default: //
#
# Splits an string into an array, using an ``MIFS``
#
# .. rubric:: Author
#
# https://stackoverflow.com/a/47633817/4166604
#**
function split_s()
{
  if [ "${1}" = "__x" ]; then
    local y
    shift 1
    split_s y ${@+"${@}"}
    __x=(${y[@]+"${y[@]}"})
  elif [ "${1}" = "__i" ]; then
    local y
    shift 1
    split_s y ${@+"${@}"}
    __i=(${y[@]+"${y[@]}"})
  elif [ "${1}" = "__target" ]; then
    local y
    shift 1
    split_s y ${@+"${@}"}
    __target=(${y[@]+"${y[@]}"})
  else
    local __target="${1}"
    shift 1

    local __x=()
    local __i
    local MIFS="${MIFS-//}"

    if [ "${MIFS-}" == "" ]; then
      echo "MIFS is not set" >&2
      return 1
    fi

    for __i in ${@+"${@}"}; do
      __i+=${MIFS}
      # If I do this before the for loop, bash 3.2 (macOS) does not work right
      while [ -n "${__i}" ]; do
        __x+=( "${__i%%${MIFS}*}" )
        __i="${__i#*${MIFS}}"
      done
    done

    # If I don't reset IFS here, dynamic_set_a will set incorrectly on bash 3.2
    dynamic_set_a "${__target}" ${__x[@]+"${__x[@]}"}
  fi
}

#**
# .. function:: join_a
#
# :Arguments: * ``$1`` - Target string name
#             * ``$2``... - Array elements
# :Parameters: * [``MIFS``] - A Multichararater Internal Field Separator.
#              * Default: //
# :Returns: Returns ``0`` on success. If no elements were passed in, returns 1. This is done to create a distinction between ``join_a x`` and ``join_a x ""``.
#
# Joins an array into a string, using an ``MIFS``
#
# .. note::
#
#    When ``1`` is returned, this is the only time the output is not compatible with :func:`split_s`.
#**
function join_a()
{
  if [ "${1}" = "__target" ]; then
    shift 1
    local y
    local rv=0
    join_a y ${@+"${@}"} || rv=$?
    __target=${y+"${y}"}
    return "${rv}"
  elif [ "${1}" = "__x" ]; then
    shift 1
    local y
    local rv=0
    join_a y ${@+"${@}"} || rv=$?
    __x=${y+"${y}"}
    return "${rv}"
  else
    if [ $# -eq 1 ]; then
      # Note: I do not `unset $1` due to the same locality-is-lost-bug referenced
      # in remove_element_a
      dynamic_set "${1}"
      return 1
    fi

    local __target="$1"
    shift 1

    local MIFS="${MIFS-//}"

    local __x="${1-}"
    shift 1

    while (( $# )); do
      __x+="${MIFS}${1}"
      shift 1
    done

    read -r "${__target}" <<< "${__x-}"
  fi
}

#**
# .. function:: join_a_out
#
# :Arguments: * ``$1`` - Hex code for IFS
#             * ``$2``... - Strings
# :Parameters: * [``MIFS``] - A Multichararater Internal Field Separator, using awk escape format. (Except for null, which is a double backslash \\x00).
#              * Default: //
#              * Note: If you are using "" or $'' notation, you will need "\\\\x00"
#
# Instead of storing the value to a variable, this outputs to stdout. Unlike :func:`join_a`, :func:`join_a_out` can handle special characters, like null. Because macOS awk is so difficult, instead of '\x00' for null, use '\\x00'. No other form of null will work on macOS. All other sed escape character should work.
#
# .. rubric:: Author
#
# https://superuser.com/a/720157/352118
#**
function join_a_out()
{
  awk -v MIFS="${MIFS-//}" \
      'function sep(){
        for(x=1;x<=length(MIFS);x++){
          if(substr(MIFS, x, 2)=="\\x"){
            c2=tolower(substr(MIFS, x+2, 1))
            c1=tolower(substr(MIFS, x+3, 1))
            k=index("123456789abcdef", c2)*16+index("123456789abcdef", c1)
            printf "%c", k
            x+=3
          }else{
            printf "%c", substr(MIFS, x, 1)
          }
        }
      }
      BEGIN{
        ORS=OFS="";
        for(i=1;i<ARGC;i++){
          print ARGV[i]
          if(ARGC-i-1){
            sep()
          }
        }
      }' ${@+"${@}"}
}

#**
# .. function:: is_array
#
# :Arguments: * ``$1`` - variable name
#
# :Output: Returns ``0`` if variable is an array, else ``1``
#
# Determines if ``$1`` is an array or not. If it is not defined, still returns ``1``
#**
if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "44" ]; then
  function is_array()
  {
    # Yes, this works with namereffing too, without having to iterate!
    if [[ ${!1@a} = *a* ]]; then
      return 0
    fi
    return 1
  }
else
  function is_array()
  {
    local signature="$(declare -p "${1}" 2>/dev/null)"

    # Handle Bash 4.2 namereffing https://stackoverflow.com/a/42877229/4166604
    local regex='^declare -[[:alpha:]]*n[[:alpha:]]* [^=]+=\"([^\"]+)\"$'
    while [[ ${signature} =~ ${regex} ]]; do
      signature="$(declare -p ${BASH_REMATCH[1]})"
    done

    # Check if is array
    regex='^declare -[[:alpha:]]*a[[:alpha:]]* '
    [[ ${signature} =~ ${regex} ]]
  }
fi

#**
# .. function:: to_array
#
# :Arguments: * ``$1`` - variable name
#
# Convert an string to an array, honoring quotes and newlines
#
# .. code-block:: bash
#
#   $ x=$'11 "2\n2" "3 \t 3 " ""'
#   $ to_array x
#   $ declare -p x
#   declare -a x=([0]="11" [1]=$'2\n2' [2]=$'3 \t 3' [3]="")
#
# .. bugs::
#
#    .. code:: bash
#
#       $ x='"f\o\\o" f\o\\o '\''f\o\\o'\'
#       $ eval "y=(${x})"
#       $ to_array x
#       $ declare -p x
#       $ declare -p y
#       declare -a x=([0]="f\\o\\\\o" [1]="fo\\o" [2]="f\\o\\\\o")
#       declare -a y=([0]="f\\o\\o" [1]="fo\\o" [2]="f\\o\\\\o")
#       # Only the double backslash in double quotes comes out wrong, due to a bug in xargs? To get around this bug, use ``eval`` instead
#**
function to_array()
{
  if ! is_array "${1}"; then
    local __x="${!1}"

    __x="$(sed '# Read all lines into one buffer
                :combine
                $bdone
                N
                bcombine
                :done
                # Escape \s so I can escape newlines
                s|\^|\\^|g
                # Escape newlines, since xargs will get confused by it
                s|\n|^^n|g' <<< "${__x}")"

    local -i __i=0
    while IFS='' read -r -d '' __y || [[ -n "${__y}" ]]; do
      declare -p __y
      __y="${__y//^^n/$'\n'}"
      __y="${__y//\\^/^}"
      declare -p __y

      # %s is important, so that printf doesn't try to replace special chracters
      IFS='' read -r -d "" "${1}[$__i]" < <(printf '%s' "${__y}") || :
      __i+=1
    done < <(xargs -n 1 printf '%s\0' <<< "${__x}")
  fi
}

#**
# .. function:: array_length
#
# :Arguments: * ``$1`` - Array name
# :Output: *stdout* - number of elements in the array. -1 for variable not defined.
#
# Echoes out the length of the array. If the variable is not defined, echos -1.
#
# .. note::
#   Does not differentiate between an array of legnth 1 and a non-array variable. Use :func:`is_array` for that
#**
function array_length()
{
  if ! declare -p "$1" &> /dev/null; then
    echo -1
  else
    _array_length "${1}[@]"
  fi
}

function _array_length()
{
  local x=(${!1+"${!1}"})
  echo "${#x[@]}"
}

#**
# .. function:: subtract_array
#
# :Arguments: * ``$1`` - Array 1
#             * ``$2`` - Array 2
#             * ``$3`` - Destination Array
#
# Destination array becomes values of array 2 not in array 1 (1 - 2). The
# destination array name can be the same as Array 1 or 2.
#**
function subtract_array()
{
  # Three indirect input variables, two possible collision variables, a bunch
  # of way to prevent collision. Basically if 1 collides, try abc, if 2, def,
  # if 3, ghi. This should allow all three to collide, without the solution
  # then colliding
  if [ "${1}" = "__i" -o "${1}" = "__j" -o "${1}" = "__output" ]; then
    if [ "${2}" = "a" -o "${3}" = "a" ]; then
      if [ "${2}" = "b" -o "${3}" = "b" ]; then
        local c="${1}[@]"
        c=(${!c+"${!c}"})
        subtract_array c "${2}" "${3}"
      else
        local b="${1}[@]"
        b=(${!b+"${!b}"})
        subtract_array b "${2}" "${3}"
      fi
    else
      local a="${1}[@]"
      a=(${!a+"${!a}"})
      subtract_array a "${2}" "${3}"
    fi
  elif [ "${2}" = "__i" -o "${2}" = "__j" -o "${2}" = "__output" ]; then
    if [ "${1}" = "d" -o "${3}" = "d" ]; then
      if [ "${1}" = "e" -o "${3}" = "e" ]; then
        local f="${2}[@]"
        f=(${!f+"${!f}"})
        subtract_array "${1}" f "${3}"
      else
        local e="${2}[@]"
        e=(${!e+"${!e}"})
        subtract_array "${1}" e "${3}"
      fi
    else
      local d="${2}[@]"
      d=(${!d+"${!d}"})
      subtract_array "${1}" d "${3}"
    fi
  elif [ "${3}" = "__i" -o "${3}" = "__j" -o "${3}" = "__output" ]; then
    if [ "${1}" = "g" -o "${2}" = "g" ]; then
      if [ "${1}" = "h" -o "${2}" = "h" ]; then
        local i="${3}[@]"
        i=(${!i+"${!i}"})
        subtract_array "${1}" "${2}" i
        dynamic_set_a "${3}" ${i[@]+"${i[@]}"}
      else
        local h="${3}[@]"
        h=(${!h+"${!h}"})
        subtract_array "${1}" "${2}" h
        dynamic_set_a "${3}" ${h[@]+"${h[@]}"}
      fi
    else
      local g="${3}[@]"
      g=(${!g+"${!g}"})
      subtract_array "${1}" "${2}" g
      dynamic_set_a "${3}" ${g[@]+"${g[@]}"}
    fi
  else
    _subtract_array "${1}[@]" "${2}[@]" "${3}"
  fi
}

function _subtract_array()
{
  local __i
  local __j
  local __output=()

  # Loop through arrays
  for __i in ${!1+"${!1}"}; do
    for __j in ${!2+"${!2}"}; do
      # If it is a match
      if [ "${__i}" = "${__j}" ]; then
        # Skip and go to the next __i
        continue 2
      fi
    done

    # If you get to this point in the outter loop, then the inner loop never
    # found a match, meaning it's a keeper!
    __output+=("${__i}")
  done

  # Clear and copy the output to the targeted name
  clear_a "$3"
  dynamic_set_a "$3" ${__output[@]+"${__output[@]}"}
}
