#!/usr/bin/env false
# Source this file

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

#*# linux/elements

#**
# ==================
# Array Manipulation
# ==================
#
# .. default-domain:: bash
#
# .. file:: elements.bsh
#
# Set of -euE safe functions to make ``bash`` array manipulation easy
#
# Set of functions for deleting, prepending and appending without repetition. Versions using actual ``Bash`` arrays are suffixed with an _a, else it works on delimiter (IFS) separated string
#
# These functions use variable indirection when possible to make using them friendlier.
#
# .. note::
#   Not intended for POSIX sh, works on bash and others like ksh
#**

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/set_flags.bsh"
source "${VSI_COMMON_DIR}/linux/isin"

#**
# .. function:: dynamic_set_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * [``$2...``] - Values to set
#
# Dynamically set an array to values from arguments
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   dynamic_set_a my_array_name 11 "2 2" 33
#   # Is like executing
#   # my_array_name=(11 "2 2" 33)
#
# .. note::
#   Does not clear the array named by ``$1``. So if the array had 4 elements in it and :func:`dynamic_set_a` is called with 3 elements, the 4th element is still set.
#
#   This is not a bug, but by design. If this was done for you, array attributes would be lost. "unset" the array prior to calling :func:`dynamic_set_a` if you wish to avoid this.
#**
function dynamic_set_a()
{
  # This way the user may use the names x, y, i, or j
  if [ "${1}" = "y" ] || [ "${1}" = "j" ]; then
    local x="${1}"
    shift 1
    local IFS='' # If I don't do this, leading and trailing whitespace are dropped
    local i
    for (( i=0; $#; i++ )); do
      read -r "${x}[$i]" <<< "${1}"
      shift 1
    done
  else
    local y="${1}"
    shift 1
    local IFS='' # If I don't do this, leading and trailing whitespace are dropped
    local j
    for (( j=0; $#; j++ )); do
      read -r "${y}[$j]" <<< "${1}"
      shift 1
    done
  fi
}

#**
# .. function:: clear_a
#
# :Arguments: ``$1`` - Name of array to be cleared
# :Output: Returns ``1`` on invalid variable name
#
# Slightly safer indirect clear array
#
# .. note::
#   Still uses eval on older versions of bash, but makes sure the variable name appears valid
#**
function clear_a()
{
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "44" ]; then
    if [ "${1}" = "x" ]; then
      local -n y="${1}"
      y=()
    else
      local -n x="${1}"
      x=()
    fi
  else
    # https://stackoverflow.com/a/2821201/4166604
    if [[ ! ${1} =~ [a-zA-Z_]+[a-zA-Z0-9_]* ]]; then
      return 1
    fi

    # Do NOT use unset here. If you do that, you will lose "local" status if the
    # variable that $1 points to has it. This can have MANY unintended
    # consequences which is generally BAD! Gotta eval :(
    # https://stackoverflow.com/questions/10497425/is-it-possible-to-use-array-in-bash#comment74842477_10497539
    eval "${1}=()"
  fi
}

#**
# .. function:: remove_element_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2`` - Value to be removed
#
# Removes all instances of a value from an array
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=(11 22 33 22 44)
#   remove_element_a x 22
#   # declare -a x='([0]="11" [1]="33" [2]="44")'
#
# .. note::
#   The resulting array is sequentially indexed, which is not typical in ``bash`` when removing elements from an array
#**
function remove_element_a()
{
  if [ "${1}" = "x" ] || [ "${1}" = "i" ]; then
    local y="${1}[@]"
    if [ "${!y+set}" == "set" ]; then
      y=( ${!y} )
    else # If it's empty/does not exist, there is nothing to remove
      return 0
    fi
    local j

    for j in "${!y[@]}"; do
      if [ "${y[$j]}" == "${2}" ]; then
        # http://wiki.bash-hackers.org/syntax/arrays#destruction
        unset "y[$j]"
      fi
    done

    clear_a "${1}"

    dynamic_set_a "${1}" ${y[@]+"${y[@]}"}
  else
    local x="${1}[@]"
    if [ "${!x+set}" == "set" ]; then
      x=( ${!x} )
    else # If it's empty/does not exist, there is nothing to remove
      return 0
    fi
    local i

    for i in "${!x[@]}"; do
      if [ "${x[$i]}" == "${2}" ]; then
        # http://wiki.bash-hackers.org/syntax/arrays#destruction
        unset "x[$i]"
      fi
    done

    clear_a "${1}"

    dynamic_set_a "${1}" ${x[@]+"${x[@]}"}
  fi
}

#**
# .. function:: remove_element
#
# :Arguments: * ``$1`` - Name of string to be set
#             * ``$2`` - String to be removed
# :Paramters: [``IFS``] - IFS Separator used
#
# String version of remove_element_a
#**
function remove_element()
{
  if [ "${1}" = "x" ]; then
    local y=()
    if [ "${!1+set}" == "set" ]; then
      y=( ${!1} )
    fi
    remove_element_a y "${2}"
    export $1=${y+"${y[*]}"}
  else
    local x=()
    if [ "${!1+set}" == "set" ]; then
      x=( ${!1} )
    fi
    remove_element_a x "${2}"
    export $1=${x+"${x[*]}"}
  fi
}

#**
# .. function:: add_element_post_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2`` - Value to be appended
#
# Add a value to the end of an array
#
# Removes all copies of the value from the array first, and then appends to the end of the array
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=(22 11 22 33)
#   add_element_post_a x 22
#   declare -p x
#   # declare -a x='([0]="11" [1]="33" [2]="22")'
#
# .. note::
#   The resulting array is sequentially indexed
#**
function add_element_post_a()
{
  remove_element_a "${1}" "${2}"
  if [ "${1}" = "x" ]; then
    local y=()
    # remove_element_a makes $1 contiguous, so no need to check $!1[@]
    if [ "${!1+set}" == "set" ]; then
      y="${1}[@]"
      y=( ${!y} )
    fi
    dynamic_set_a "${1}" ${y[@]+"${y[@]}"} "${2}"
  else
    local x=()
    # remove_element_a makes $1 contiguous, so no need to check $!1[@]
    if [ "${!1+set}" == "set" ]; then
      x="${1}[@]"
      x=( ${!x} )
    fi
    dynamic_set_a "${1}" ${x[@]+"${x[@]}"} "${2}"
  fi
}

#**
# .. function:: add_element_post
#
# :Arguments: * ``$1`` - Name of string to be set
#             * ``$2`` - String to be appended
# :Parameters: [``IFS``] - IFS Separator used
#
# String version of :func:`add_element_post_a`
#**
function add_element_post()
{
  if [ "${1}" = "x" ]; then
    local y=()
    if [ "${!1+set}" == "set" ]; then
      y=( ${!1} )
    fi
    add_element_post_a y "${2}"
    export $1=${y+"${y[*]}"}
  else
    local x=()
    if [ "${!1+set}" == "set" ]; then
      x=( ${!1} )
    fi
    add_element_post_a x "${2}"
    export $1=${x+"${x[*]}"}
  fi
}

#**
# .. function:: add_element_pre_a
#
# :Arguments: * ``$1`` - Name of array to be set
#             * ``$2`` - Value to be prepended
#
# Add a value to the beginning of an array
#
# Removes all copies of the value from the array first, and then prepends to the beginning of the array
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=(11 22 33 22)
#   add_element_pre_a x 22
#   declare -p x
#   # declare -a x='([0]="22" [1]="11" [2]="33")'
#
# .. note::
#   The resulting array is sequentially indexed
#**
function add_element_pre_a()
{
  remove_element_a "${1}" "${2}"
  if [ "${1}" = "x" ]; then
    local y=()
    # remove_element_a makes $1 contiguous, so no need to check $!1[@]
    if [ "${!1+set}" == "set" ]; then
      y="${1}[@]"
      y=( ${!y} )
    fi
    dynamic_set_a "${1}" "${2}" ${y+"${y[@]}"}
  else
    local x=()
    # remove_element_a makes $1 contiguous, so no need to check $!1[@]
    if [ "${!1+set}" == "set" ]; then
      x="${1}[@]"
      x=( ${!x} )
    fi
    dynamic_set_a "${1}" "${2}" ${x+"${x[@]}"}
  fi
}

#**
# .. function:: add_element_pre
#
# :Arguments: * ``$1`` - Name of string to be set
#             * ``$2`` - String to be appended
# :Parameters: [``IFS``] - IFS Separator used
#
# String version of :func:`add_element_post_a`
#**
function add_element_pre ()
{
  if [ "${1}" = "x" ]; then
    local y=()
    if [ "${!1+set}" == "set" ]; then
      y=( ${!1} )
    fi
    add_element_pre_a y "${2}"
    export $1=${y+"${y[*]}"}
  else
    local x=()
    if [ "${!1+set}" == "set" ]; then
      x=( ${!1} )
    fi
    add_element_pre_a x "${2}"
    export $1=${x+"${x[*]}"}
  fi
}

#**
# .. function:: cmp_elements_a
#
# :Arguments: * ``$1`` - First array name
#             * ``$2`` - Second array name
# :Output: Return Value: ``0`` - Identical, ``1`` - Not identical
#
# Checks if two arrays are the same
#**
function cmp_elements_a()
{
  # # Handle the trivial case. This isn't neccessary since as it happens using
  # # "x x" or "y y" yields the correct answer, this just bypasses that
  # if [ "${1}" = "${2}" ]; then
  #   return 0
  # fi
  # Handling this corner case would just slow things down in the normal case

  # Swap the order, so that only 1 could be x, and only 2 could be y. This will
  # simplify the logic below.
  if [ "${1}" = "y" ] || [ "${2}" = "x" ]; then
    set -- "${2}" "${1}"
  fi

  # It happens that the below will work if both arguments are x or y, although
  # "x" works through a "buggy" route (y ends up being a copy of the copy of x,
  # rather than just a copy of x), but the answer is correct, so it's all good

  # Have to copy https://unix.stackexchange.com/a/374094/123413 Thanks darwin!
  if [ "${1}" = "i" -a "${2}" = "j" -o "${1}" = "j" -a "${2}" = "i" ]; then
    local k="${1}[@]"
    local x=(${!k+"${!k}"})
    k="${2}[@]"
    local y=(${!k+"${!k}"})
  elif [ "${1}" = "i" -o "${2}" = "i" ]; then
    local j="${1}[@]"
    local x=(${!j+"${!j}"})
    j="${2}[@]"
    local y=(${!j+"${!j}"})
  else
    local i="${1}[@]"
    local x=(${!i+"${!i}"})
    i="${2}[@]"
    local y=(${!i+"${!i}"})
  fi

  if [ ${#x[@]} -ne ${#y[@]} ]; then
    return 1
  fi

  local z
  for ((z=0; z<${#x[@]}; z++)); do
    if [ "${x[$z]}" != "${y[$z]}" ]; then
      return 1
    fi
  done

  return 0
}

#**
# .. function:: cmp_elements
#
# :Arguments: * ``$1`` - First string name
#             * ``$2`` - Second string name
# :Output: Return Value: ``0`` - Identical, ``1`` - Not identical
#
# String version of :func:`cmp_elements_a`
#**
function cmp_elements()
{
  # Handle the trivial case. This is neccessary unlike the array version,
  # because x/y are strings, not arrays, and the logic breaks down
  if [ "${1}" = "${2}" ]; then
    return 0
  fi

  # Swap the order, so that only 1 could be x, and only 2 could be y. This will
  # simplify the logic below.
  if [ "${1}" = "y" ] || [ "${2}" = "x" ]; then
    set -- "${2}" "${1}"
  fi

  local x=( ${!1} )
  local y=( ${!2} )

  cmp_elements_a x y
  return $?
}

#**
# .. function:: split_s
#
# :Arguments: * ``$1`` - Target array name
#             * ``$2``... - Strings
# :Parameters: * [``MIFS``] - A Multichararater Internal Field Separator.
#              * Default: //
#
# Splits an string into an array, using an ``MIFS``
#
# .. rubric:: Author
#
# https://stackoverflow.com/a/47633817/4166604
#**
function split_s()
{
  if [ "${1}" = "x" ] || [ "${1}" = "i" ] || [ "${1}" = "var" ]; then
    local target="${1}"
    shift 1

    local y=()
    local j
    local MIFS="${MIFS-//}"

    if [ "${MIFS-}" == "" ]; then
      echo "MIFS is not set" >&2
      return 1
    fi

    for j in ${@+"${@}"}; do
      j+=${MIFS}
      # If I do this before the for loop, bash 3.2 (macOS) does not work right
      while [ -n "${j}" ]; do
        y+=( "${j%%${MIFS}*}" )
        j="${j#*${MIFS}}"
      done
    done

    # If I don't reset IFS here, dynamic_set_a will set incorrectly on bash 3.2
    dynamic_set_a "${target}" ${y[@]+"${y[@]}"}
  else
    local var="${1}"
    shift 1

    local x=()
    local i
    local MIFS="${MIFS-//}"

    if [ "${MIFS-}" == "" ]; then
      echo "MIFS is not set" >&2
      return 1
    fi

    for i in ${@+"${@}"}; do
      i+=${MIFS}
      # If I do this before the for loop, bash 3.2 (macOS) does not work right
      while [ -n "${i}" ]; do
        x+=( "${i%%${MIFS}*}" )
        i="${i#*${MIFS}}"
      done
    done

    # If I don't reset IFS here, dynamic_set_a will set incorrectly on bash 3.2
    dynamic_set_a "${var}" ${x[@]+"${x[@]}"}
  fi
}

#**
# .. function:: join_a
#
# :Arguments: * ``$1`` - Target array name
#             * ``$2``... - Strings
# :Parameters: * [``MIFS``] - A Multichararater Internal Field Separator.
#             * Default: //
#
# Joins an array into a string, using an ``MIFS``
#**
function join_a()
{
  if [ "${1}" = "x" ] || [ "${1}" = "x_s" ]; then
    if [ $# -eq 1 ]; then
      return 0
      # This means target is never set. This mirrors the behavior of split_s.
      # Note: I do not `unset $1` due to the same locality-is-lost-bug referenced
      # in remove_element_a
    fi

    local y="$1"
    shift 1

    local MIFS="${MIFS-//}"

    local y_s="${1-}"
    shift 1

    while [ $# -gt 0 ]; do
      y_s+="${MIFS}${1}"
      shift 1
    done

    read -r "${y}" <<< "${y_s-}"
  else
    if [ $# -eq 1 ]; then
      return 0
      # This means target is never set. This mirrors the behavior of split_s.
      # Note: I do not `unset $1` due to the same locality-is-lost-bug referenced
      # in remove_element_a
    fi

    local x="$1"
    shift 1

    local MIFS="${MIFS-//}"

    local x_s="${1-}"
    shift 1

    while [ $# -gt 0 ]; do
      x_s+="${MIFS}${1}"
      shift 1
    done

    read -r "${x}" <<< "${x_s-}"
  fi
}

#**
# .. function:: join_a_out
#
# :Arguments: * ``$1`` - Hex code for IFS
#             * ``$2``... - Strings
# :Parameters: * [``MIFS``] - A Multichararater Internal Field Separator, using awk escape format. (Except for null, which is a double backslash \\x00).
#              * Default: //
#              * Note: If you are using "" or $'' notation, you will need "\\\\x00"
#
# Instead of storing the value to a variable, this outputs to stdout. Unlike :func:`join_a`, :func:`join_a_out` can handle special characters, like null. Because macOS awk is so difficult, instead of '\x00' for null, use '\\x00'. No other form of null will work on macOS. All other sed escape character should work.
#
# .. rubric:: Author
#
# https://superuser.com/a/720157/352118
#**
function join_a_out()
{
  awk -v MIFS="${MIFS-//}" \
      'function sep(){
        for(x=1;x<=length(MIFS);x++){
          if(substr(MIFS, x, 2)=="\\x"){
            c2=tolower(substr(MIFS, x+2, 1))
            c1=tolower(substr(MIFS, x+3, 1))
            k=index("123456789abcdef", c2)*16+index("123456789abcdef", c1)
            printf "%c", k
            x+=3
          }else{
            printf "%c", substr(MIFS, x, 1)
          }
        }
      }
      BEGIN{
        ORS=OFS="";
        for(i=1;i<ARGC;i++){
          print ARGV[i]
          if(ARGC-i-1){
            sep()
          }
        }
      }' ${@+"${@}"}
}

#**
# .. function:: is_array
#
# :Arguments: * ``$1`` - variable name
#
# :Output: Returns ``0`` if variable is an array, else ``1``
#
# Determines if ``$1`` is an array or not. If it is not defined, still returns ``1``
#**
function is_array()
{
  local signature="$(declare -p "${1}" 2>/dev/null)"

  # Handle Bash 4.2 namereffing https://stackoverflow.com/a/42877229/4166604
  local regex='^declare -[[:alpha:]]*n[[:alpha:]]* [^=]+=\"([^\"]+)\"$'
  while [[ ${signature} =~ ${regex} ]]; do
    signature="$(declare -p ${BASH_REMATCH[1]})"
  done

  # Check if is array
  regex='^declare -[[:alpha:]]*a[[:alpha:]]* '
  [[ ${signature} =~ ${regex} ]]
}

#**
# .. function:: to_array
#
# :Arguments: * ``$1`` - variable name
#
# .. Note::
#   Uses eval to convert to array, because of this, () and other special characters can cause code injection
#
#   .. code-block:: bash
#
#     $ x="test); echo foo; q=("
#     $ to_array x
#     foo
#
#     $ x="test\)\; echo foo; \("
#     # or
#     $ x="'test);' echo 'foo;' '('"
#     $ to_array x
#     # Works without side effect
#**
function to_array()
{
  # Don't try and escape special characters, cause then you end up putting \'s
  # in quoted string, which is not what we want
  if ! is_array "${1}"; then
    # Eval method :(
    eval "$1=(${!1})"
  fi
}

#**
# .. function:: array_length
#
# :Arguments: * ``$1`` - Array name
# :Output: *stdout* - number of elements in the array. -1 for variable not defined.
#
# Echoes out the length of the array. If the variable is not defined, echos -1.
#
# .. note::
#   Does not differentiate between an array of legnth 1 and a non-array variable. Use :func:`is_array` for that
#**
function array_length()
{
  if ! declare -p "$1" &> /dev/null; then
    echo -1
  elif [ "${1}" = "x" ]; then
    local y="$1[@]"
    y=(${!y+"${!y}"})
    echo "${#y[@]}"
  else
    local x="$1[@]"
    x=(${!x+"${!x}"})
    echo "${#x[@]}"
  fi
}

#**
# .. function:: subtract_array
#
# :Arguments: * ``$1`` - Array 1
#             * ``$2`` - Array 2
#             * ``$3`` - Destination Array
#
# Destination array becomes values of array 2 not in array 1 (1 - 2). The
# destination array name can be the same as Array 1 or 2.
#
# .. rubric:: Bugs
#
# Don't use array names:
#
#   * __element_array_target_temp1
#   * __element_array_target_temp2
#
# as an argument. It will cause name collision.
#**
function subtract_array()
{
  local __element_array_target_temp1=("" "$1[@]" "$2[@]" 0)
  # __element_array_target_temp1 ends up being a multi-purpose variable in order
  # to shrink the number of variables that can possibly collide with parent
  # functions.
  # - 0 - The loop first loop variable
  # - 1 - The string $1[@] needed for variable indirection
  # - 2 - The string $2[@] needed for variable indirection
  # - 3 - Boolean that stores whether a particular element should be included
  #       in the final subtracted array
  local __element_array_target_temp2=("")
  # - 0 - The loop first loop variable
  # - 1... - A copy of the output

  for __element_array_target_temp1 in ${!__element_array_target_temp1[1]+"${!__element_array_target_temp1[1]}"}; do
    for __element_array_target_temp2 in ${!__element_array_target_temp1[2]+"${!__element_array_target_temp1[2]}"}; do
      if [ "${__element_array_target_temp1}" = "${__element_array_target_temp2}" ]; then
        __element_array_target_temp1[3]=1
        break
      fi
    done

    # If this element survives subtraction
    if [ "${__element_array_target_temp1[3]}" = "0" ]; then
      # Copy it to the output array. This is copied rather than going directly
      # to the output array, incase the user sets the input and output array
      # the same
      __element_array_target_temp2+=("${__element_array_target_temp1[0]}")
    fi
    __element_array_target_temp1[3]=0
  done

  clear_a "$3"
  if [ "${#__element_array_target_temp2[@]}" -gt 1 ]; then
    dynamic_set_a "$3" "${__element_array_target_temp2[@]:1}"
  fi
}
